"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// TODO: what happens if an error is thrown inside a middleware/listener function? it should propagate up and eventually
// be dealt with by the global error handler
function processMiddleware(initialArguments, middleware, afterMiddleware, afterPostProcess, context = {}) {
    // Generate next()
    let middlewareIndex = 0;
    const postProcessFns = [];
    const next = (errorOrPostProcess) => {
        middlewareIndex += 1;
        const thisMiddleware = middleware[middlewareIndex];
        // Continue processing
        if (thisMiddleware !== undefined && !(errorOrPostProcess instanceof Error)) {
            const isLastMiddleware = middlewareIndex === (middleware.length - 1);
            const nextWhenNotLast = isLastMiddleware ? noop : next;
            // In this condition, errorOrPostProcess will be a postProcess function or undefined
            postProcessFns[middlewareIndex - 1] = errorOrPostProcess === undefined ? noopPostProcess : errorOrPostProcess;
            thisMiddleware({ context, next: nextWhenNotLast, ...initialArguments });
            if (isLastMiddleware) {
                postProcessFns[middlewareIndex] = noopPostProcess;
                process.nextTick(next);
            }
            return;
        }
        // Processing is complete, and we should begin bubbling up
        // there's no next middleware or the argument is an error
        function createDone(initialIndex) {
            let postProcessIndex = initialIndex;
            // done is a function that handles bubbling up in a similar way to next handling propogating down
            const done = (error) => {
                postProcessIndex -= 1;
                const thisPostProcess = postProcessFns[postProcessIndex];
                if (thisPostProcess !== undefined) {
                    thisPostProcess(error, done);
                    return;
                }
                afterPostProcess(error);
            };
            return done;
        }
        if (thisMiddleware === undefined) {
            afterMiddleware(context, initialArguments, (error) => {
                createDone(middleware.length)(error);
            });
        }
        else {
            createDone(middlewareIndex - 1)(errorOrPostProcess);
        }
    };
    const firstMiddleware = middleware[0];
    firstMiddleware({ context, next, ...initialArguments });
}
exports.processMiddleware = processMiddleware;
function noop() { } // tslint:disable-line:no-empty
const noopPostProcess = (error, done) => { done(error); };
//# sourceMappingURL=process.js.map