"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = __importDefault(require("util"));
const web_api_1 = require("@slack/web-api");
const logger_1 = require("@slack/logger");
const ExpressReceiver_1 = __importDefault(require("./ExpressReceiver"));
const builtin_1 = require("./middleware/builtin");
const process_1 = require("./middleware/process");
const conversation_store_1 = require("./conversation-store");
const helpers_1 = require("./helpers");
const errors_1 = require("./errors");
const packageJson = require('../package.json'); // tslint:disable-line:no-require-imports no-var-requires
var logger_2 = require("@slack/logger");
exports.LogLevel = logger_2.LogLevel;
/**
 * A Slack App
 */
class App {
    constructor({ signingSecret = undefined, endpoints = undefined, receiver = undefined, convoStore = undefined, token = undefined, botId = undefined, botUserId = undefined, authorize = undefined, logger = new logger_1.ConsoleLogger(), logLevel = logger_1.LogLevel.INFO, ignoreSelf = true, } = {}) {
        this.logger = logger;
        this.logger.setLevel(logLevel);
        this.errorHandler = defaultErrorHandler(this.logger);
        // TODO: other webclient options (such as proxy)
        this.client = new web_api_1.WebClient(undefined, { logLevel });
        if (token !== undefined) {
            if (authorize !== undefined) {
                throw errors_1.errorWithCode(`Both token and authorize options provided. ${tokenUsage}`, errors_1.ErrorCode.AppInitializationError);
            }
            this.authorize = singleTeamAuthorization(this.client, { botId, botUserId, botToken: token });
        }
        else if (authorize === undefined) {
            throw errors_1.errorWithCode(`No token and no authorize options provided. ${tokenUsage}`, errors_1.ErrorCode.AppInitializationError);
        }
        else {
            this.authorize = authorize;
        }
        this.middleware = [];
        this.listeners = [];
        // Check for required arguments of ExpressReceiver
        if (signingSecret !== undefined) {
            this.receiver = new ExpressReceiver_1.default({ signingSecret, logger, endpoints });
        }
        else if (receiver === undefined) {
            // Check for custom receiver
            throw errors_1.errorWithCode('Signing secret not found, so could not initialize the default receiver. Set a signing secret or use a ' +
                'custom receiver.', errors_1.ErrorCode.AppInitializationError);
        }
        else {
            this.receiver = receiver;
        }
        // Subscribe to messages and errors from the receiver
        this.receiver.on('message', message => this.onIncomingEvent(message));
        this.receiver.on('error', error => this.onGlobalError(error));
        // Conditionally use a global middleware that ignores events (including messages) that are sent from this app
        if (ignoreSelf) {
            this.use(builtin_1.ignoreSelf());
        }
        // Use conversation state global middleware
        if (convoStore !== false) {
            // Use the memory store by default, or another store if provided
            const store = convoStore === undefined ? new conversation_store_1.MemoryStore() : convoStore;
            this.use(conversation_store_1.conversationContext(store, this.logger));
        }
    }
    /**
     * Register a new middleware, processed in the order registered.
     *
     * @param m global middleware function
     */
    use(m) {
        this.middleware.push(m);
        return this;
    }
    /**
     * Convenience method to call start on the receiver
     *
     * TODO: args could be defined using a generic constraint from the receiver type
     *
     * @param args receiver-specific start arguments
     */
    start(...args) {
        return this.receiver.start(...args);
    }
    stop(...args) {
        return this.receiver.stop(...args);
    }
    event(eventName, ...listeners) {
        this.listeners.push([builtin_1.onlyEvents, builtin_1.matchEventType(eventName), ...listeners]);
    }
    message(...patternsOrMiddleware) {
        const messageMiddleware = patternsOrMiddleware.map((patternOrMiddleware) => {
            if (typeof patternOrMiddleware === 'string' || util_1.default.types.isRegExp(patternOrMiddleware)) {
                return builtin_1.matchMessage(patternOrMiddleware);
            }
            return patternOrMiddleware;
        });
        this.listeners.push([builtin_1.onlyEvents, builtin_1.matchEventType('message'), ...messageMiddleware]);
    }
    action(actionIdOrConstraints, ...listeners) {
        const constraints = (typeof actionIdOrConstraints === 'string' || util_1.default.types.isRegExp(actionIdOrConstraints)) ?
            { action_id: actionIdOrConstraints } : actionIdOrConstraints;
        // Fail early if the constraints contain invalid keys
        const unknownConstraintKeys = Object.keys(constraints)
            .filter(k => (k !== 'action_id' && k !== 'block_id' && k !== 'callback_id'));
        if (unknownConstraintKeys.length > 0) {
            this.logger.error(`Action listener cannot be attached using unknown constraint keys: ${unknownConstraintKeys.join(', ')}`);
            return;
        }
        this.listeners.push([builtin_1.onlyActions, builtin_1.matchConstraints(constraints), ...listeners]);
    }
    // TODO: should command names also be regex?
    command(commandName, ...listeners) {
        this.listeners.push([builtin_1.onlyCommands, builtin_1.matchCommandName(commandName), ...listeners]);
    }
    options(actionIdOrConstraints, ...listeners) {
        const constraints = (typeof actionIdOrConstraints === 'string' || util_1.default.types.isRegExp(actionIdOrConstraints)) ?
            { action_id: actionIdOrConstraints } : actionIdOrConstraints;
        this.listeners.push([builtin_1.onlyOptions, builtin_1.matchConstraints(constraints), ...listeners]);
    }
    error(errorHandler) {
        this.errorHandler = errorHandler;
    }
    /**
     * Handles events from the receiver
     */
    async onIncomingEvent({ body, ack, respond }) {
        // TODO: when generating errors (such as in the say utility) it may become useful to capture the current context,
        // or even all of the args, as properties of the error. This would give error handling code some ability to deal
        // with "finally" type error situations.
        // Introspect the body to determine what type of incoming event is being handled, and any channel context
        const { type, conversationId } = helpers_1.getTypeAndConversation(body);
        // If the type could not be determined, warn and exit
        if (type === undefined) {
            this.logger.warn('Could not determine the type of an incoming event. No listeners will be called.');
            return;
        }
        // From this point on, we assume that body is not just a key-value map, but one of the types of bodies we expect
        const bodyArg = body;
        // Initialize context (shallow copy to enforce object identity separation)
        const source = buildSource(type, conversationId, bodyArg);
        const authorizeResult = await (this.authorize(source, bodyArg).catch((error) => {
            this.onGlobalError(authorizationErrorFromOriginal(error));
        }));
        if (authorizeResult === undefined) {
            this.logger.warn('Authorization of incoming event did not succeed. No listeners will be called.');
            return;
        }
        const context = { ...authorizeResult };
        // Factory for say() utility
        const createSay = (channelId) => {
            const token = context.botToken !== undefined ? context.botToken : context.userToken;
            return (message) => {
                const postMessageArguments = (typeof message === 'string') ?
                    { token, text: message, channel: channelId } : { ...message, token, channel: channelId };
                this.client.chat.postMessage(postMessageArguments)
                    .catch(error => this.onGlobalError(error));
            };
        };
        // Set body and payload (this value will eventually conform to AnyMiddlewareArgs)
        // NOTE: the following doesn't work because... distributive?
        // const listenerArgs: Partial<AnyMiddlewareArgs> = {
        const listenerArgs = {
            body: bodyArg,
            payload: (type === helpers_1.IncomingEventType.Event) ?
                bodyArg.event :
                (type === helpers_1.IncomingEventType.Action &&
                    isBlockActionOrInteractiveMessageBody(bodyArg)) ?
                    bodyArg.actions[0] :
                    bodyArg,
        };
        // Set aliases
        if (type === helpers_1.IncomingEventType.Event) {
            const eventListenerArgs = listenerArgs;
            eventListenerArgs.event = eventListenerArgs.payload;
            if (eventListenerArgs.event.type === 'message') {
                const messageEventListenerArgs = eventListenerArgs;
                messageEventListenerArgs.message = messageEventListenerArgs.payload;
            }
        }
        else if (type === helpers_1.IncomingEventType.Action) {
            const actionListenerArgs = listenerArgs;
            actionListenerArgs.action = actionListenerArgs.payload;
        }
        else if (type === helpers_1.IncomingEventType.Command) {
            const commandListenerArgs = listenerArgs;
            commandListenerArgs.command = commandListenerArgs.payload;
        }
        else if (type === helpers_1.IncomingEventType.Options) {
            const optionListenerArgs = listenerArgs;
            optionListenerArgs.options = optionListenerArgs.payload;
        }
        // Set say() utility
        if (conversationId !== undefined && type !== helpers_1.IncomingEventType.Options) {
            listenerArgs.say = createSay(conversationId);
        }
        // Set respond() utility
        if (respond !== undefined) {
            listenerArgs.respond = respond;
        }
        // Set ack() utility
        if (type !== helpers_1.IncomingEventType.Event) {
            listenerArgs.ack = ack;
        }
        else {
            // Events API requests are acknowledged right away, since there's no data expected
            ack();
        }
        // Dispatch event through global middleware
        process_1.processMiddleware(listenerArgs, this.middleware, (globalProcessedContext, globalProcessedArgs, startGlobalBubble) => {
            this.listeners.forEach((listenerMiddleware) => {
                // Dispatch event through all listeners
                process_1.processMiddleware(globalProcessedArgs, listenerMiddleware, (_listenerProcessedContext, _listenerProcessedArgs, startListenerBubble) => {
                    startListenerBubble();
                }, (error) => {
                    startGlobalBubble(error);
                }, globalProcessedContext);
            });
        }, (globalError) => {
            if (globalError !== undefined) {
                this.onGlobalError(globalError);
            }
        }, context);
    }
    /**
     * Global error handler. The final destination for all errors (hopefully).
     */
    onGlobalError(error) {
        this.errorHandler(errors_1.asCodedError(error));
    }
}
exports.default = App;
const tokenUsage = 'Apps used in one workspace should be initialized with a token. Apps used in many workspaces ' +
    'should be initialized with a authorize.';
/**
 * Helper which builds the data structure the authorize hook uses to provide tokens for the context.
 */
function buildSource(type, channelId, body) {
    // NOTE: potentially something that can be optimized, so that each of these conditions isn't evaluated more than once.
    // if this makes it prettier, great! but we should probably check perf before committing to any specific optimization.
    // tslint:disable:max-line-length
    const source = {
        teamId: ((type === helpers_1.IncomingEventType.Event || type === helpers_1.IncomingEventType.Command) ? body.team_id :
            (type === helpers_1.IncomingEventType.Action || type === helpers_1.IncomingEventType.Options) ? body.team.id :
                helpers_1.assertNever(type)),
        enterpriseId: ((type === helpers_1.IncomingEventType.Event || type === helpers_1.IncomingEventType.Command) ? body.enterprise_id :
            (type === helpers_1.IncomingEventType.Action || type === helpers_1.IncomingEventType.Options) ? body.team.enterprise_id :
                undefined),
        userId: ((type === helpers_1.IncomingEventType.Event) ?
            ((typeof body.event.user === 'string') ? body.event.user :
                (typeof body.event.user === 'object') ? body.event.user.id :
                    (body.event.channel !== undefined && body.event.channel.creator !== undefined) ? body.event.channel.creator :
                        (body.event.subteam !== undefined && body.event.subteam.created_by !== undefined) ? body.event.subteam.created_by :
                            undefined) :
            (type === helpers_1.IncomingEventType.Action || type === helpers_1.IncomingEventType.Options) ? body.user.id :
                (type === helpers_1.IncomingEventType.Command) ? body.user_id :
                    undefined),
        conversationId: channelId,
    };
    // tslint:enable:max-line-length
    return source;
}
function isBlockActionOrInteractiveMessageBody(body) {
    return body.actions !== undefined;
}
function defaultErrorHandler(logger) {
    return (error) => {
        logger.error(error);
    };
}
function singleTeamAuthorization(client, authorization) {
    // TODO: warn when something needed isn't found
    const botUserId = authorization.botUserId !== undefined ?
        Promise.resolve(authorization.botUserId) :
        client.auth.test({ token: authorization.botToken })
            .then(result => result.user_id);
    const botId = authorization.botId !== undefined ?
        Promise.resolve(authorization.botId) :
        botUserId.then(id => client.users.info({ token: authorization.botToken, user: id }))
            .then(result => result.user.profile.bot_id);
    return async () => ({
        botToken: authorization.botToken,
        botId: await botId,
        botUserId: await botUserId,
    });
}
/* Instrumentation */
web_api_1.addAppMetadata({ name: packageJson.name, version: packageJson.version });
/* Error handling helpers */
function authorizationErrorFromOriginal(original) {
    const error = errors_1.errorWithCode('Authorization of incoming event did not succeed.', errors_1.ErrorCode.AuthorizationError);
    error.original = original;
    return error;
}
//# sourceMappingURL=App.js.map